\section{Fine-Grained Routing}

%\cb{Devesh: Currently holding lock on this section.: not any more}

The first step towards achieving higher performance is to place LNET routers equidistant from each other as much as possible,
subject to physical constraints and other boundary conditions. This ensures that LNET routers are distributed across the machine
and are not segregated in a particular zone. The second key step is to pair clients with their closet possible LNET router. This 
section discusses the algorithm that pairs a client with the closet possible LNET router to minimize hop counts and congestion.

Recall that there are a total 440 LNET routers where only 432 routers are used for file I/O and rest 8 are used for meta data I/O.
Four LNET routers together form a router module, resulting in a total of 108 router modules in the system. These 108 router modules 
are divided into 9 groups. Each group is further divided into 4 sub-groups. Each sub-group consists of 3 router modules. Therefore, each 
group consists of 12 router modules.

%\cb{Devesh: need to describe why 4 and 9? it is because of corresponding rows and columns of DDN storage racks?}

Algorithm~\ref{alg:fgr} describes how a client chooses the closet router module within the assigned group. We note that
the client to group pairing is decided using a fixed arrangement. Before we describe the algorithm in detail, we first
describe how a particular router module is denoted in our algorithm depending on its association with a particular group and sub-group. The 
$i^{th}$ router module in the $G^{th}$ group and $S^{th}$ sub-group is denoted as $R^G_{i}(S)$. Based on 
our previous discussion, we can infer that $G$, $S$ and $i$ will have following respective ranges: ($1, \dots, 9$), ($1, \dots, 4$), 
and ($1, \dots, 3$).

The algorithm takes two input parameters: first, coordinates of the client ($C$) and second, the group it belongs to ($R^G$). The 
algorithm returns the coordinates of three routers assigned to the input client ($C$), one primary and two backup routers. 

Our fine-grained algorithm consists of two steps. The first step (line~\ref{first:begin}--\ref{first:end}) is to choose the sub-group whose 
Y-coordinates fall within the close range of Y-coordinates of the input client, $C$. This is because the bandwidth in the Y-direction is limited
compared to other directions, as discussed earlier. Therefore, it is desirable to minimize the traffic in that direction first. 

Once the sub-group is selected, the second step (line~\ref{second:begin}--\ref{second:end}) is to return assigned routers from this sub-group.
As mentioned earlier, each sub-group consists of 3 routers and the algorithm returns a vector of 3 routers. So, all three of them are 
returned, but the one with the lowest distance in X-dimension is assigned as the primary router to minimize the hops and avoid congestion 
in that direction. We note that the X-direction crosses cabinet boundaries, therefore it more desirable to minimize the hops in that 
direction compared to the Z-direction that run within a cabinet in vertical direction.


\begin{algorithm}
\caption{Fine-grained routing algorithm}
\label{alg:fgr}
\begin{algorithmic}[1]
\Procedure {Route Selection Algorithm }{$R^G$, $C$} \\ 
%\hrulefill
\State Divide $R^G$ into 4 sub-groups: $R^G(1)$ \ldots $R^G(4)$.

\ForAll{sub-groups $R^G(i)$} \Comment{$i$ ranges 1 to 4}
\label{first:begin}
    \State $C[y]$ $\leftarrow$ y coordinate of $C$
    \State $R^G_{1}(i)$ $\leftarrow$ first router module in the $i^{th}$ sub-group
    \State $R^G_{1}(i)[y]$ $\leftarrow$ y coordinate of $R^G_{i}(S)$
    \If{ ($C[y] == R^G_{1}(i)[y]-1$) 
    \\ \hspace{\algorithmicindent} \hspace{\algorithmicindent}   or ($C[y] == R^G_{1}(i)[y]$)
    \\ \hspace{\algorithmicindent} \hspace{\algorithmicindent}   or ($C[y] == R^G_{1}(i)[y] + 1$) 
    \\ \hspace{\algorithmicindent} \hspace{\algorithmicindent}   or ($C[y] == R^G_{1}(i)[y] + 2$)}
    \State break with sub-group $i$ selected
    \EndIf
\EndFor
\label{first:end}

\\ 

\State $i$ $\leftarrow$ index of selected sub-group
\label{second:begin}
\State $r_1, r_2, r_3$ $\leftarrow$ first, second, and third router module 
\State \hspace{\algorithmicindent} selected sub-group $i$

\State $d_{min}$ $\leftarrow$ $\infty$ 
\State $Index_{primary}$ $\leftarrow$ $\infty$

\\

\For{$j$ in $1, \dots, 3$}
    \State $d_{current}$ $\leftarrow$ dist($C[x], r_j[x]$) \Comment{distance along $X$ dimension}
        \If{$d_{current}$ $<$ $d_{min}$}
        \State $Index_{primary}$ $\leftarrow$ $j$
        \EndIf

%    \State primary router module $\leftarrow$ min($d_min$)
%    \State backup router modules $\leftarrow$ 
%    \IndState{0} two other modules in the sub-group 
\EndFor

    \State primary router module $\leftarrow$ $R^G_{Index_{primary}}(i)$
    \State backup router modules $\leftarrow$ 
    \IndState{0} two other modules in the $i^{th}$ sub-group

    \Return $<$primary and backup router modules$>$ \\ 

\label{second:end}

\EndProcedure
\\
%\hrulefill
\end{algorithmic}
\end{algorithm}

\begin{comment}
With router placement in place, we now face the question that, how does each
client select which router to minimize communication hops as well as to avoid
congestion. This section provides an overview on route selection process and
algorithms. Routers are divided into 9 groups, with each group containing 12
router modules. We denote a router group with a superscript, and a router
module in that group with a subscript. For example, the first module in a
router group $A$ is denoted as $R^A_1$ so on and so forth. The following
algorithm describe the core idea of selection process. The input is a given
router group and client ID, the output is a triple: primary router and two back
up routers.
\end{comment}

%Zones in the network

%Return traffic routing

%FGR scripts

% vim:textwidth=80:
