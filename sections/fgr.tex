\section{Fine-Grained Routing}

\cb{Devesh: Currently holding lock on this section.}

The first step towards achieving higher performance is to place LNET routers equidistant from each other as much as possible,
subject to physical constraints and other boundary conditions. This ensures that LNET routers are distributed across the machine
and are not segregated in a particular zone. The second key step is to pair clients with their closet possible LNET router. This 
section discusses the algorithm that pairs a client with the closet possible LNET router to minimize hop counts and congestion.

Recall that there are a total 440 LNET routers where only 432 routers are used for file I/O and rest 8 are used for meta data I/O.
These 432 LNET routers are divided into four domains, so each domain has 108 routers \cb{Devesh: need to double check this}. Each
domain is divided into 9 groups. Each group is further divided into 4 sub-group. Each sub-group consists of has 3 LNET routers. That 
is, each domain has a total of 108 routers, divided into total 9 groups and 36 sub-groups.

Algorithm
Algorithm~\ref{algo:fgr} describes.

The $i^{th}$ router in the $G^{th}$ group and $S^{th}$ sub-group within that  $G^{th}$ group is denoted as $R^G_{i}(S)$. Based on 
our previous discussion, we can infer that $G$, $S$ and $i$ will have following respective ranges: ($1, \dots, 12$), ($1, \dots, 4$), 
and ($1, \dots, 3$).


\begin{algorithmic}[1]
\label{algo:fgr}
\Procedure {Route Selection Algorithm }{$R^x$, $C$} \\ \hrulefill

\State Divide $R^x$ into 4 sub-groups: $R^x(1)$ \ldots $R^x(4)$.

\ForAll{subgroups $R^x(i)$}
    \State $C_y$ $\leftarrow$ y coordinate of $C$
    \State $R$ $\leftarrow$ first router module in current subgroup
    \State $R_y$ $\leftarrow$ y coordinate of $R$
    \If{$C_y == R_y-1$ or $C_y == R_y$ or \\
       \hspace{\algorithmicindent} \hspace{\algorithmicindent} $C_y == R_y + 1$ or $C_y == R_y + 2$}
    \State break with subgroup $i$ selected
    \EndIf
\EndFor


With router placement in place, we now face the question that, how does each
client select which router to minimize communication hops as well as to avoid
congestion. This section provides an overview on route selection process and
algorithms. Routers are divided into 9 groups, with each group containing 12
router modules. We denote a router group with a superscript, and a router
module in that group with a subscript. For example, the first module in a
router group $A$ is denoted as $R^A_1$ so on and so forth. The following
algorithm describe the core idea of selection process. The input is a given
router group and client ID, the output is a triple: primary router and two back
up routers.



\State $i$ $\leftarrow$ index of selected subgroup
\State $r_1, r_2, r_3$ $\leftarrow$ first, second, and third router module 
\State \hspace{\algorithmicindent} selected subgroup $i$

\ForAll{$r_1, r_2, r_3$}
    \State $d_i$ $\leftarrow$ dist($C, r_i$) \Comment{distance along $X$ dimension}
    \State primary router module $\leftarrow$ min($d_i$)
    \State backup router modules $\leftarrow$ 
    \IndState{0} two other modules in the subgroup 
\EndFor

\EndProcedure
\\\hrulefill
\end{algorithmic}


%Zones in the network

%Return traffic routing

%FGR scripts

% vim:textwidth=80:
