\section{Fine-Grained Routing}

\cb{Devesh: Currently holding lock on this section.}

The first step towards achieving higher performance is to place LNET routers equidistant from each other as much as possible,
subject to physical constraints and other boundary conditions. This ensures that LNET routers are distributed across the machine
and are not segregated in a particular zone. The second key step is to pair clients with their closet possible LNET router. This 
section discusses the algorithm that pairs a client with the closet possible LNET router to minimize hop counts and congestion.

Recall that there are a total 440 LNET routers where only 432 routers are used for file I/O and rest 8 are used for meta data I/O.
These 432 LNET routers are divided into four domains, so each domain has 108 routers \cb{Devesh: need to double check this}. Each
domain is divided into 9 groups. Each group is further divided into 4 sub-group. Each sub-group consists of has 3 LNET routers. That 
is, each domain has a total of 108 routers, divided into total 9 groups and 36 sub-groups.

\cb{Devesh: need to describe why 4 and 9? it is because of corresponding rows and columns of DDN storage racks?}

Algorithm~\ref{alg:fgr} describes how a client chooses the closet LNET router. Before we describe the algorithm in detail, we first
describe how a particular router is denoted in our algorithm depending on its association with a particular group and subgroup. The 
$i^{th}$ router in the $G^{th}$ group and $S^{th}$ sub-group within that $G^{th}$ group is denoted as $R^G_{i}(S)$. Based on 
our previous discussion, we can infer that $G$, $S$ and $i$ will have following respective ranges: ($1, \dots, 12$), ($1, \dots, 4$), 
and ($1, \dots, 3$).

The algorithm takes two input parameters: first, coordinates of the client ($C$) and second, the group it belongs to ($R^x$). \cb{Devesh: need to add 
how do we decide a node's corresponding group id?}. The algorithm returns the coordinates of three routers assigned to the input client ($C$),
one primary and two backup routers.

Our fine-grained algorithm consists of two steps. The first step (line~\ref{first:begin}--\ref{first:end}) is to choose the subgroup whose 
Y-coordinates fall within the close range of Y-coordinates of the input client, $C$. This is because bandwidth in the Y-direction is limited
compared to other directions, as discussed earlier. Therefore, it is desirable to minimize the traffic in that direction first. \cb{Devesh: I 
guess the intuition is correct. need to double check with Feiyi. How the range is decided?}

Once the subgroup is selected, the second step (line~\ref{second:begin}--\ref{second:end}) to return assigned routers from this sub-group.
As mentioned earlier, each subgroup consists of 3 routers and the algorithm returns a vector of 3 routers. So, all three of them are 
returned, but the one with the lowest distance in X-dimension is assigned as the primary router to minimize the hops and avoid congestion 
in that direction. \cb{Devesh: Why we don't choose Z direction?.}


\begin{algorithm}
\caption{Fine-grained routing algorithm}
\label{alg:fgr}
\begin{algorithmic}[1]
\Procedure {Route Selection Algorithm }{$R^G$, $C$} \\ 
%\hrulefill
\State Divide $R^G$ into 4 sub-groups: $R^G(1)$ \ldots $R^G(4)$.

\ForAll{subgroups $R^G(S)$}
\label{first:begin}
    \State $C[y]$ $\leftarrow$ y coordinate of $C$
    \State $R^G_{i}(S)$ $\leftarrow$ first router module in current sub-group
    \State $R^G_{i}(S)[y]$ $\leftarrow$ y coordinate of $R^G_{i}(S)$
    \If{$C[y] == R^G_{i}(S)[y]-1$ or $C[y] == R^G_{i}(S)[y]$ or \\
       \hspace{\algorithmicindent} \hspace{\algorithmicindent} $C[y] == R^G_{i}(S)[y] + 1$ or $C[y] == R^G_{i}(S)[y] + 2$}
    \State break with sub-group $i$ selected
    \EndIf
\EndFor
\label{first:end}

\State $i$ $\leftarrow$ index of selected sub-group
\label{second:begin}
\State $r_1, r_2, r_3$ $\leftarrow$ first, second, and third router module 
\State \hspace{\algorithmicindent} selected sub-group $i$

\State $d_{min}$ $\leftarrow$ $\infty$ 
\State $Index_{primary}$ $\leftarrow$ $\infty$

\For{$j$ in $1, \dots, 3$}
    \State $d_{current}$ $\leftarrow$ dist($C[x], r_j[x]$) \Comment{distance along $X$ dimension}
        \If{$d_{current}$ $<$ $d_{min}$}
        \State $Index_{primary}$ $\leftarrow$ $j$
        \EndIf

%    \State primary router module $\leftarrow$ min($d_min$)
%    \State backup router modules $\leftarrow$ 
%    \IndState{0} two other modules in the subgroup 
\EndFor

    \State primary router module $\leftarrow$ $R^G_{Index_{primary}}(i)$
    \State backup router modules $\leftarrow$ 
    \IndState{0} two other modules in the $i^{th}$ subgroup

\label{second:end}

\EndProcedure
\\
%\hrulefill
\end{algorithmic}
\end{algorithm}

\begin{comment}
With router placement in place, we now face the question that, how does each
client select which router to minimize communication hops as well as to avoid
congestion. This section provides an overview on route selection process and
algorithms. Routers are divided into 9 groups, with each group containing 12
router modules. We denote a router group with a superscript, and a router
module in that group with a subscript. For example, the first module in a
router group $A$ is denoted as $R^A_1$ so on and so forth. The following
algorithm describe the core idea of selection process. The input is a given
router group and client ID, the output is a triple: primary router and two back
up routers.
\end{comment}

%Zones in the network

%Return traffic routing

%FGR scripts

% vim:textwidth=80:
